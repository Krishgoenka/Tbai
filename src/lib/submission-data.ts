
import { z } from 'zod';
import { submissionSchema, type Submission } from '@/app/admin/submissions/schema';
import { db, storage } from './firebase';
import { collection, getDocs, addDoc, query, orderBy, where, limit, setDoc, doc } from 'firebase/firestore';
import { ref, uploadBytes, getDownloadURL } from 'firebase/storage';

const submissionsCollection = collection(db, 'submissions');

// Type for adding a submission, ID is generated by Firestore.
type AddSubmissionData = Omit<Submission, 'id' | 'fileUrl'>;

export async function getSubmissions() {
  try {
    const q = query(submissionsCollection, orderBy("submissionDate", "desc"));
    const querySnapshot = await getDocs(q);
    const submissions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    
    return z.array(submissionSchema).parse(submissions);
  } catch (error) {
    console.error("Error fetching submissions: ", error);
    return [];
  }
}

export async function addSubmission(submissionData: AddSubmissionData, file: File, existingSubmissionId?: string) {
    try {
        // 1. Upload file to Firebase Storage
        const storageRef = ref(storage, `submissions/${submissionData.assignmentId}/${Date.now()}_${file.name}`);
        const snapshot = await uploadBytes(storageRef, file);
        const downloadUrl = await getDownloadURL(snapshot.ref);

        // 2. Create the submission document with the file URL
        const submissionWithFile: Omit<Submission, 'id'> = {
            ...submissionData,
            fileUrl: downloadUrl,
        }
        
        // 3. If it's a resubmission, update the existing document. Otherwise, create a new one.
        if (existingSubmissionId) {
            const docRef = doc(db, 'submissions', existingSubmissionId);
            await setDoc(docRef, submissionWithFile, { merge: true });
            return { ...submissionWithFile, id: existingSubmissionId };
        } else {
            const docRef = await addDoc(submissionsCollection, submissionWithFile);
            return { ...submissionWithFile, id: docRef.id };
        }

    } catch (error) {
        console.error("Error adding submission: ", error);
        throw new Error("Failed to add submission.");
    }
}

export async function getSubmissionsForStudent(studentEmail: string) {
    try {
        const q = query(submissionsCollection, where("studentEmail", "==", studentEmail));
        const querySnapshot = await getDocs(q);
        const submissions = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
        return z.array(submissionSchema).parse(submissions);
    } catch (error) {
        console.error(`Error fetching submissions for ${studentEmail}:`, error);
        return [];
    }
}

export async function getStudentSubmissionForAssignment(studentEmail: string, assignmentId: string) {
    try {
        const q = query(
            submissionsCollection, 
            where("studentEmail", "==", studentEmail), 
            where("assignmentId", "==", assignmentId),
            limit(1)
        );
        const querySnapshot = await getDocs(q);
        if (querySnapshot.empty) {
            return null;
        }
        const doc = querySnapshot.docs[0];
        return submissionSchema.parse({ id: doc.id, ...doc.data() });
    } catch (error) {
        console.error(`Error fetching specific submission for ${studentEmail}:`, error);
        return null;
    }
}
